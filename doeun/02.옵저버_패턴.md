# 옵저버 패턴

## 들어가며

`addEventListener`를 쓸 때, Redux의 `subscribe`를 호출할 때, React Query가 캐시를 갱신할 때 — 우리는 이미 옵저버 패턴 위에서 코드를 쓰고 있다.

그런데 이 패턴을 정확히 이해하지 못하면 이런 상황이 생긴다.

> 분명 상태를 바꿨는데 UI가 안 바뀐다.
> 컴포넌트를 하나 추가했을 뿐인데 기존 코드를 세 군데나 고쳐야 한다.
> 언마운트했는데 콜백이 계속 호출된다.

이 글에서는 옵저버 패턴이 뭔지, 왜 필요한지, 실무에서 어떻게 쓰이는지를 코드와 함께 정리한다.

---

## 옵저버 패턴이 뭔데?

한 줄로 요약하면 이렇다.

> **"내 상태가 바뀌면, 나를 지켜보고 있는 애들한테 알려줄게."**

등장인물은 딱 둘이다.

**Subject(발행자)** 는 상태를 가지고 있는 쪽이다. 상태가 바뀌면 "바뀌었다!"고 외친다. **Observer(구독자)** 는 Subject한테 "나한테도 알려줘"라고 등록해둔 쪽이다. 알림이 오면 각자 할 일을 한다.

유튜브 구독을 떠올리면 쉽다. 채널(Subject)이 영상을 올리면 구독자(Observer)들에게 알림이 간다. 채널은 구독자가 누구인지 일일이 신경 쓰지 않는다. 그냥 "새 영상 올렸어"라고 알리면 끝이다.

이걸 코드로 옮기면 이렇게 생겼다.

```javascript
class Subject {
  constructor() {
    this.observers = new Set();
  }

  // 구독: "나한테도 알려줘"
  subscribe(observer) {
    this.observers.add(observer);
    return () => this.observers.delete(observer);
  }

  // 알림: "상태 바뀌었어!"
  notify(data) {
    this.observers.forEach((observer) => observer(data));
  }
}
```

`subscribe`로 구독하고, `notify`로 알린다. 20줄도 안 되는 코드지만, 이 구조 하나로 해결할 수 있는 문제가 꽤 많다.

그럼 이 구조가 실제로 어떤 문제를 해결하는지 Before/After 코드로 비교해보자.

---

## 왜 필요한데?

### 상황: 쇼핑몰 장바구니

장바구니에 상품을 담으면 세 군데가 동시에 반응해야 한다. 헤더의 장바구니 뱃지 숫자, 사이드바의 총 금액, 그리고 추천 섹션의 필터링이다.

### ❌ Before — 옵저버 패턴 없이

```javascript
class Cart {
  constructor() {
    this.items = [];

    // Cart가 UI 컴포넌트를 직접 알고 있어야 한다
    this.headerBadge = null;
    this.sidebar = null;
    this.recommendationEngine = null;
  }

  addItem(item) {
    this.items.push(item);

    // UI가 하나 추가될 때마다 여기를 수정해야 한다
    if (this.headerBadge) {
      this.headerBadge.updateCount(this.items.length);
    }
    if (this.sidebar) {
      this.sidebar.updateTotal(this.calculateTotal());
    }
    if (this.recommendationEngine) {
      this.recommendationEngine.refilter(this.items);
    }
    // 위시리스트 비교 기능 추가하면? 여기에 또 if문 추가...
    // 재고 알림 기능 추가하면? 여기에 또 if문 추가...
  }

  calculateTotal() {
    return this.items.reduce((sum, item) => sum + item.price, 0);
  }
}
```

문제가 보이는가?

Cart라는 도메인 로직이 헤더, 사이드바, 추천 엔진이라는 UI 레이어에 완전히 묶여 있다. UI가 하나 추가될 때마다 Cart 클래스를 열어서 `addItem`을 수정해야 한다. `sidebar`가 아직 `null`이면 `if` 분기가 필요하고, 컴포넌트가 늦게 마운트되면 그 사이에 발생한 변경은 그냥 놓친다. 테스트하려면 HeaderBadge, Sidebar, RecommendationEngine의 mock을 전부 만들어야 한다.

한마디로, Cart가 너무 많은 걸 알고 있다.

### ✅ After — 옵저버 패턴 적용

```javascript
class Cart {
  constructor() {
    this.items = [];
    this.listeners = new Map();
  }

  subscribe(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    this.listeners.get(event).add(callback);
    return () => this.listeners.get(event)?.delete(callback);
  }

  notify(event, data) {
    this.listeners.get(event)?.forEach((cb) => cb(data));
  }

  addItem(item) {
    this.items.push(item);

    // Cart는 누가 듣고 있는지 전혀 모른다
    // 그냥 "아이템 추가됐어"라고 알릴 뿐이다
    this.notify('item:added', {
      items: [...this.items],
      total: this.calculateTotal(),
    });
  }

  calculateTotal() {
    return this.items.reduce((sum, item) => sum + item.price, 0);
  }
}
```

Cart의 `addItem`이 깔끔해졌다. 더 이상 UI 컴포넌트를 하나하나 호출하지 않는다. 그냥 `notify`로 "아이템이 추가됐다"는 사실을 알릴 뿐이다.

이제 각 UI는 자기가 필요할 때 알아서 구독한다.

```javascript
const cart = new Cart();

// 헤더 뱃지: 개수만 필요하다
const unsubBadge = cart.subscribe('item:added', ({ items }) => {
  headerBadge.updateCount(items.length);
});

// 사이드바: 총액만 필요하다
const unsubSidebar = cart.subscribe('item:added', ({ total }) => {
  sidebar.updateTotal(total);
});

// 추천 엔진: 아이템 목록이 필요하다
const unsubReco = cart.subscribe('item:added', ({ items }) => {
  recommendationEngine.refilter(items);
});

// 나중에 위시리스트 비교 기능이 추가된다면?
// Cart 코드는 건드릴 필요 없다. 구독 한 줄만 추가하면 된다.
const unsubWishlist = cart.subscribe('item:added', ({ items }) => {
  wishlist.compare(items);
});

// 컴포넌트가 사라질 때 구독 해제
unsubBadge();
```

Cart 코드는 UI가 몇 개든 상관없이 그대로다. 각 구독자는 같은 이벤트에서 자기한테 필요한 데이터만 골라 쓴다. 그리고 `subscribe`가 해제 함수를 반환하니까 생명주기 관리도 깔끔하다.

이 차이를 설계 원칙으로 설명하면 "느슨한 결합"이라는 개념이 된다.

---

## 느슨한 결합이 왜 중요한가

헤드 퍼스트 디자인 패턴에서는 옵저버 패턴을 설명하면서 이런 디자인 원칙을 강조한다.

> **"상호작용하는 객체 사이에는 가능하면 느슨한 결합을 사용해야 한다."**

느슨한 결합이란, 두 객체가 서로 상호작용은 하지만 서로에 대해 자세히 모르는 관계를 뜻한다. 위의 Before/After를 이 관점에서 다시 보면, 단순히 "코드가 깔끔해졌다"를 넘어서 구조적으로 뭐가 달라졌는지가 더 선명해진다.

```javascript
cart.subscribe('item:added', updateBadge);    // UI 업데이트? 몰라
cart.subscribe('item:added', sendAnalytics);  // 분석 이벤트? 몰라
cart.subscribe('item:added', syncToServer);   // 서버 동기화? 몰라
```

Cart는 "콜백 함수가 등록되어 있다"는 사실만 안다. 그게 뱃지를 업데이트하는 함수인지, 분석 이벤트를 보내는 함수인지, 서버에 동기화하는 함수인지 전혀 모른다. 알 필요도 없다.

이게 왜 실무에서 중요할까? 프론트엔드에서 요구사항 변경은 일상이기 때문이다. "여기에 알림도 띄워주세요", "이 데이터를 분석 툴에도 보내주세요" 같은 요청이 올 때, 느슨하게 결합된 시스템에서는 구독 한 줄을 추가하면 끝이다. Before 코드처럼 강하게 결합된 시스템에서는 Cart 클래스를 열어서 `addItem` 메서드를 수정해야 한다.

정리하면 느슨한 결합이 가져다주는 이점은 이렇다.

Subject는 Observer의 구체적인 구현을 모르기 때문에, 새로운 구독자가 추가되거나 기존 구독자가 빠져도 Subject 코드는 한 줄도 바뀌지 않는다. 이건 OCP(개방-폐쇄 원칙) 그 자체다. 또한 Subject와 Observer는 독립적으로 재사용할 수 있다. Cart 클래스를 다른 프로젝트에 가져가도 그대로 동작한다. 구독자가 없으면 `notify`가 아무 일도 안 할 뿐이다.

그리고 한쪽이 바뀌어도 다른 쪽에 영향을 주지 않는다. 사이드바의 UI를 완전히 뜯어고쳐도 Cart는 모른다. Cart의 내부 로직이 바뀌어도, `notify`로 보내는 데이터 구조만 유지하면 모든 구독자는 그대로 동작한다.

느슨한 결합이 옵저버 패턴의 "왜"를 설명한다면, 다음에 나오는 Push vs Pull은 옵저버 패턴의 "어떻게"를 결정하는 문제다.

---

## Push vs Pull — 데이터를 밀어줄까, 당겨갈까

옵저버 패턴을 구현할 때 하나의 설계 결정을 내려야 한다. 상태가 바뀌었을 때 Subject가 데이터를 밀어줄 것인가(Push), Observer가 필요한 걸 직접 가져갈 것인가(Pull).

### Push 방식

Subject가 변경된 데이터를 알림과 함께 통째로 보내준다. 지금까지 본 코드가 전부 이 방식이다.

```javascript
this.notify('item:added', {
  items: [...this.items],
  total: this.calculateTotal(),
  count: this.items.length,
  lastAdded: item,
});
```

간편하지만 문제가 있다. Subject가 "구독자들이 뭘 필요로 할지"를 미리 예측해서 데이터를 구성해야 한다는 점이다. 구독자가 늘어날수록 보내야 할 데이터도 점점 비대해진다. 뱃지 컴포넌트는 `count` 하나만 필요한데, 매번 전체 `items` 배열의 복사본까지 받는 건 낭비다.

### Pull 방식

반대로 Pull 방식에서는 Subject가 "바뀌었다"는 신호만 보내고, Observer가 필요한 데이터를 직접 꺼내간다.

```javascript
class Cart {
  constructor() {
    this.items = [];
    this.listeners = new Set();
  }

  subscribe(callback) {
    this.listeners.add(callback);
    return () => this.listeners.delete(callback);
  }

  notify() {
    // 데이터 없이 "바뀌었다"는 사실만 알린다
    this.listeners.forEach((cb) => cb());
  }

  addItem(item) {
    this.items.push(item);
    this.notify();
  }

  // Observer가 필요할 때 직접 꺼내가는 getter들
  getItems() { return [...this.items]; }
  getTotal() { return this.items.reduce((sum, i) => sum + i.price, 0); }
  getCount() { return this.items.length; }
}
```

```javascript
const cart = new Cart();

// 뱃지: count만 필요하니까 count만 가져간다
cart.subscribe(() => {
  headerBadge.updateCount(cart.getCount());
});

// 사이드바: total만 가져간다
cart.subscribe(() => {
  sidebar.updateTotal(cart.getTotal());
});
```

Subject가 구독자의 요구사항을 예측할 필요가 없다. 각 Observer가 자기한테 필요한 것만 골라 가져가니까 데이터 낭비도 없다.

### 실무에서는 둘을 섞어 쓴다

사실 대부분의 실무 코드는 Push와 Pull을 적절히 섞는다.

```javascript
addItem(item) {
  this.items.push(item);

  // 대부분의 구독자가 쓰는 핵심 데이터는 Push
  this.notify('item:added', { count: this.items.length });

  // 전체 아이템 목록처럼 무거운 데이터가 필요한 구독자는
  // cart.getItems()로 직접 Pull
}
```

이미 익숙한 도구들도 이 하이브리드 방식을 쓰고 있다. Redux에서 `dispatch`하면 "상태 바뀌었어"라고 알리고(Push), 각 컴포넌트는 `useSelector`로 자기한테 필요한 조각만 꺼내간다(Pull). React Query도 마찬가지다. 캐시가 업데이트되면 알림이 가고, 각 `useQuery` 훅이 자기 쿼리 키에 해당하는 데이터만 가져간다.

---

## 바닐라 JS SPA에서의 상태 관리

지금까지 옵저버 패턴의 개념과 원칙을 살펴봤다. 이제 이걸 가장 날것으로 체감할 수 있는 예시를 보자. 프레임워크 없이 바닐라 JS로 SPA를 만들 때의 상태 관리다.

프레임워크 없이 SPA를 만들어본 적이 있다면, 상태가 바뀔 때 DOM을 직접 업데이트하는 게 얼마나 번거로운지 알 거다. 할 일을 추가하면 리스트도 다시 그리고, 카운터도 바꾸고, 필터 상태도 확인해야 한다. 기능이 추가될 때마다 모든 핸들러를 열어서 수정해야 한다.

옵저버 패턴으로 간단한 스토어를 만들면 이 문제가 구조적으로 풀린다.

### 먼저 스토어를 만든다

```javascript
function createStore(initialState) {
  let state = initialState;
  const listeners = new Set();

  return {
    getState() {
      return state;
    },

    setState(updater) {
      const nextState =
        typeof updater === 'function' ? updater(state) : updater;
      state = { ...state, ...nextState };

      // 상태가 바뀌면 모든 구독자에게 알린다 — 이게 옵저버 패턴이다
      listeners.forEach((listener) => listener(state));
    },

    subscribe(listener) {
      listeners.add(listener);
      return () => listeners.delete(listener);
    },
  };
}
```

상태를 보관하고, 바뀌면 구독자에게 알린다. 이게 전부다. React의 `useState`가 내부적으로 하는 일도 본질적으로 이것과 같다.

### 이 스토어로 할 일 앱을 만들어보자

```javascript
// 1) 스토어 생성
const store = createStore({
  todos: [],
  filter: 'all', // 'all' | 'active' | 'completed'
});
```

```javascript
// 2) 렌더 함수들 — 각자 자기 영역만 다시 그린다
function renderTodoList(state) {
  const list = document.getElementById('todo-list');
  const filtered = state.todos.filter((todo) => {
    if (state.filter === 'active') return !todo.done;
    if (state.filter === 'completed') return todo.done;
    return true;
  });

  list.innerHTML = filtered
    .map(
      (todo) => `
      <li data-id="${todo.id}" class="${todo.done ? 'completed' : ''}">
        <label>
          <input type="checkbox" ${todo.done ? 'checked' : ''} />
          ${todo.text}
        </label>
        <button class="delete-btn">삭제</button>
      </li>
    `
    )
    .join('');
}

function renderCount(state) {
  const counter = document.getElementById('todo-count');
  const active = state.todos.filter((t) => !t.done).length;
  counter.textContent = `할 일 ${active}개 남음`;
}

function renderFilter(state) {
  document.querySelectorAll('[data-filter]').forEach((btn) => {
    btn.classList.toggle('active', btn.dataset.filter === state.filter);
  });
}
```

```javascript
// 3) 구독 — 상태가 바뀌면 각 렌더 함수가 자동으로 호출된다
store.subscribe(renderTodoList);
store.subscribe(renderCount);
store.subscribe(renderFilter);
```

```javascript
// 4) 이벤트 핸들러 — 상태만 바꾸면 된다. DOM은 신경 쓰지 않는다.
document.getElementById('todo-form').addEventListener('submit', (e) => {
  e.preventDefault();
  const input = e.target.querySelector('input');

  store.setState((prev) => ({
    todos: [
      ...prev.todos,
      { id: Date.now(), text: input.value, done: false },
    ],
  }));

  input.value = '';
});

document.getElementById('todo-list').addEventListener('click', (e) => {
  const li = e.target.closest('li');
  if (!li) return;
  const id = Number(li.dataset.id);

  if (e.target.type === 'checkbox') {
    store.setState((prev) => ({
      todos: prev.todos.map((t) =>
        t.id === id ? { ...t, done: !t.done } : t
      ),
    }));
  }

  if (e.target.classList.contains('delete-btn')) {
    store.setState((prev) => ({
      todos: prev.todos.filter((t) => t.id !== id),
    }));
  }
});

document.querySelector('.filters').addEventListener('click', (e) => {
  if (e.target.dataset.filter) {
    store.setState({ filter: e.target.dataset.filter });
  }
});
```

여기서 주목할 점은, 이벤트 핸들러가 DOM을 직접 건드리지 않는다는 것이다. 할 일을 추가할 때 `list.innerHTML`을 직접 바꾸지 않고, `store.setState`만 호출한다. 그러면 옵저버 패턴에 의해 `renderTodoList`, `renderCount`, `renderFilter`가 자동으로 호출된다.

흐름을 정리하면 이렇다.

> **사용자 이벤트 → setState → notify → 각 렌더 함수 자동 호출**

이 구조가 익숙하게 느껴진다면 맞다. React, Vue, Svelte 같은 프레임워크들이 내부적으로 하는 일이 정확히 이것이다. 프레임워크가 우리 대신 옵저버 패턴을 돌려주고 있을 뿐이다.

---

## 언제 도입해야 할까

옵저버 패턴이 좋다고 해서 모든 상태 공유에 써야 하는 건 아니다. 아래 조건 중 2개 이상 해당되면 도입을 고려할 시점이다.

**상태 변경을 받는 쪽이 유동적일 때.** 소비자가 고정되어 있으면 직접 호출이 더 간단하다. 하지만 런타임에 소비자가 추가되거나 제거된다면 — 동적으로 마운트되는 위젯, 플러그인 시스템, 대시보드 타일 같은 경우 — 옵저버 패턴이 자연스러운 해법이다.

**하나의 이벤트를 여러 관점에서 해석해야 할 때.** Cart 예시에서 "아이템 추가됨"이라는 하나의 이벤트를 뱃지는 "개수"로, 사이드바는 "총액"으로, 추천 엔진은 "카테고리 분포"로 해석했다. 같은 사건인데 관심사가 전부 다르다면 옵저버 패턴이 딱 맞는다.

**의존 방향을 뒤집어야 할 때.** Cart → HeaderBadge 방향의 의존은 도메인이 UI를 아는 구조다. 옵저버 패턴을 쓰면 UI가 도메인을 구독하는 형태가 되어, 클린 아키텍처의 의존성 규칙과 자연스럽게 맞아떨어진다.

**Prop drilling이 감당이 안 될 때.** React에서 3단계 이상의 prop drilling이 발생하거나 형제 컴포넌트끼리 상태를 공유해야 할 때, Context나 전역 스토어보다 가벼운 이벤트 기반 통신이 더 효율적일 수 있다.

---

## TypeScript로 타입 안전하게 만들기

옵저버 패턴을 실무에 적용하다 보면 금방 부딪히는 문제가 있다. 이벤트 이름이 전부 문자열이라는 점이다. 오타 하나에 구독이 연결되지 않고, 어떤 이벤트에 어떤 데이터가 오는지 코드만 봐서는 알 수 없다.

TypeScript의 제네릭으로 이벤트 맵을 정의하면 이 문제가 깔끔하게 해결된다.

```typescript
// 이벤트 이름과 데이터 형태를 한 곳에서 정의한다
type EventMap = {
  'cart:updated': { items: CartItem[]; total: number };
  'auth:changed': { isLoggedIn: boolean; userId: string | null };
  'theme:toggled': { mode: 'light' | 'dark' };
};

class TypedEventEmitter<T extends Record<string, unknown>> {
  private listeners = new Map<keyof T, Set<(data: any) => void>>();

  on<K extends keyof T>(event: K, callback: (data: T[K]) => void): () => void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    this.listeners.get(event)!.add(callback);
    return () => this.listeners.get(event)?.delete(callback);
  }

  emit<K extends keyof T>(event: K, data: T[K]): void {
    this.listeners.get(event)?.forEach((cb) => cb(data));
  }
}
```

사용할 때의 경험이 확 달라진다.

```typescript
const emitter = new TypedEventEmitter<EventMap>();

// data의 타입이 자동 추론된다
emitter.on('cart:updated', (data) => {
  console.log(data.total); // number로 추론
  console.log(data.items); // CartItem[]로 추론
});

// 잘못된 이벤트 이름은 컴파일 타임에 잡힌다
emitter.on('cart:updateddd', () => {}); // ❌ 타입 에러!

// 잘못된 데이터 형태도 컴파일 타임에 잡힌다
emitter.emit('auth:changed', { isLoggedIn: 'yes' }); // ❌ boolean이어야 함
```

이벤트 이름 오타나 잘못된 페이로드 같은 실수를, 런타임에 디버깅하는 게 아니라 코드를 쓰는 시점에 잡을 수 있다. 문자열 기반 이벤트 시스템을 실무에서 쓸 거라면 이 정도 타입 안전성은 필수다.

---

## 실무 활용 사례

개념을 이해했으니 실무에서 옵저버 패턴이 어떻게 녹아드는지 몇 가지 대표적인 사례를 보자.

### 사례 1: 전역 토스트 알림 시스템

여러 곳에서 토스트를 띄워야 하는데 Toast UI 컴포넌트는 앱에 하나만 있다. API 에러 인터셉터에서도, 폼 제출 성공 시에도, 웹소켓 이벤트에서도 토스트를 띄워야 한다.

옵저버 패턴 없이는 Toast 컴포넌트의 setState에 접근할 방법을 모든 곳에 만들어줘야 한다. 옵저버 패턴이 있으면 이벤트 하나 발행하면 끝이다.

```javascript
const toastBus = new TypedEventEmitter();

// 발행하는 쪽 (여러 곳에서 자유롭게)
axios.interceptors.response.use(null, (error) => {
  toastBus.emit('toast:show', {
    type: 'error',
    message: error.response?.data?.message ?? '요청에 실패했습니다.',
  });
  return Promise.reject(error);
});

toastBus.emit('toast:show', { type: 'success', message: '저장되었습니다.' });
```

```javascript
// 구독하는 쪽 (딱 한 곳)
function ToastContainer() {
  const [toasts, setToasts] = useState([]);

  useEffect(() => {
    const unsub = toastBus.on('toast:show', (toast) => {
      const id = crypto.randomUUID();
      setToasts((prev) => [...prev, { ...toast, id }]);
      setTimeout(() => {
        setToasts((prev) => prev.filter((t) => t.id !== id));
      }, 3000);
    });
    return unsub;
  }, []);

  return toasts.map((t) => <Toast key={t.id} {...t} />);
}
```

발행자가 누구든, 몇 명이든 상관없다. ToastContainer는 그냥 `toast:show` 이벤트를 듣고 있을 뿐이다.

### 사례 2: WebSocket 메시지 라우팅

하나의 WebSocket 연결로 채팅, 알림, 실시간 데이터가 전부 들어온다. 이걸 각 컴포넌트에 어떻게 분배할까?

```javascript
class WebSocketRouter {
  constructor(url) {
    this.emitter = new TypedEventEmitter();
    this.ws = new WebSocket(url);

    this.ws.onmessage = (event) => {
      const { type, payload } = JSON.parse(event.data);
      this.emitter.emit(type, payload);
    };
  }

  on(messageType, handler) {
    return this.emitter.on(messageType, handler);
  }
}

const ws = new WebSocketRouter('wss://api.example.com/ws');

ws.on('chat:message', (msg) => appendMessage(msg));
ws.on('notification', (notif) => showNotification(notif));
ws.on('data:tick', (tick) => updateChart(tick));
```

WebSocket 라우터는 채팅 컴포넌트가 있는지, 차트가 있는지 모른다. 메시지가 오면 타입별로 발행할 뿐이고, 해당 타입을 구독하고 있는 쪽이 알아서 처리한다. 이것도 느슨한 결합이다.

### 사례 3: 멀티 스텝 폼 상태 동기화

Step 3에서 입력한 보험 정보가 Step 1의 요약 미리보기에 실시간으로 반영되어야 한다. prop drilling 없이, 전역 스토어 없이.

```javascript
const formBus = new TypedEventEmitter();

// Step 3: 보험 정보 입력
function InsuranceStep() {
  const handleChange = (field, value) => {
    formBus.emit('form:field-changed', { step: 'insurance', field, value });
  };
  // ...
}

// Step 1의 요약 미리보기 — Step 3의 존재를 모른다
function SummaryPreview() {
  const [preview, setPreview] = useState({});

  useEffect(() => {
    return formBus.on('form:field-changed', ({ step, field, value }) => {
      setPreview((prev) => ({ ...prev, [`${step}.${field}`]: value }));
    });
  }, []);

  return <PreviewCard data={preview} />;
}
```

### 사례 4: IntersectionObserver로 무한 스크롤

브라우저 네이티브 API인 `IntersectionObserver`도 이름 그대로 옵저버 패턴이다. 특정 요소가 화면에 보이는지를 "관찰"하고, 보이면 콜백을 호출한다.

```javascript
function useIntersectionObserver(callback, options = {}) {
  const targetRef = useRef(null);

  useEffect(() => {
    const observer = new IntersectionObserver(([entry]) => {
      if (entry.isIntersecting) callback();
    }, options);

    const target = targetRef.current;
    if (target) observer.observe(target);

    return () => {
      if (target) observer.unobserve(target);
    };
  }, [callback, options.threshold, options.root]);

  return targetRef;
}
```

```javascript
function ProductList() {
  const { data, fetchNextPage } = useInfiniteQuery(/* ... */);
  const sentinelRef = useIntersectionObserver(fetchNextPage);

  return (
    <>
      {data.pages.flat().map((product) => (
        <ProductCard key={product.id} {...product} />
      ))}
      {/* 이 빈 div가 뷰포트에 들어오면 → 다음 페이지 로드 */}
      <div ref={sentinelRef} />
    </>
  );
}
```

---

## 사실 이미 쓰고 있는 옵저버 패턴들

여기까지 읽으면서 "이거 어디서 많이 본 건데?"라는 느낌이 들었을 수 있다. 맞다. 프론트엔드 생태계 곳곳에 옵저버 패턴이 녹아 있다. 이걸 인식하면 각 도구의 설계 의도가 더 선명하게 보인다.

| 도구 / API | Subject (발행자) | Observer (구독자) | 언제 알림이 가나? |
|---|---|---|---|
| `addEventListener` | DOM 요소 | 이벤트 핸들러 | 클릭, 입력 등 사용자 인터랙션 |
| React `useState` | 컴포넌트 상태 | 렌더 함수 | `setState` 호출 |
| Redux `store.subscribe` | Store | Listener 함수 | `dispatch` |
| `MutationObserver` | DOM 노드 | 콜백 함수 | DOM 구조 변경 |
| `IntersectionObserver` | 타겟 요소 | 콜백 함수 | 뷰포트 교차 |
| RxJS `Observable` | 데이터 스트림 | Subscriber | 새 값 발행 |
| React Query | 쿼리 캐시 | 컴포넌트 | 캐시 무효화 / 갱신 |

---

## 주의해야 할 함정들

패턴이 유용한 만큼, 잘못 쓰면 생기는 문제도 명확하다.

### 메모리 누수

가장 흔한 실수다. 구독해놓고 해제를 안 하면 컴포넌트가 화면에서 사라져도 콜백은 계속 호출된다. React에서는 `useEffect`의 cleanup에서 반드시 unsubscribe를 호출해야 한다.

```javascript
useEffect(() => {
  const unsub = emitter.on('some:event', handler);
  return unsub; // ← 이걸 빠뜨리면 메모리 누수
}, []);
```

앞에서 `subscribe`가 해제 함수를 반환하도록 설계한 이유가 바로 이것이다. 구독과 해제를 한 쌍으로 묶어서, 빠뜨리기 어렵게 만든다.

### 실행 순서 의존

옵저버들이 호출되는 순서는 보장되지 않는다. "A 옵저버가 먼저 실행되고 나서 B가 실행되어야 해"라는 로직이 있다면, 옵저버 패턴을 잘못 쓰고 있다는 신호다. 순서가 중요하면 파이프라인 패턴이나 미들웨어 체인을 고려해야 한다.

### 디버깅 난이도

이벤트 기반 시스템은 콜스택만으로 흐름을 추적하기 어렵다. 이벤트 이름을 `domain:action` 형태로 일관되게 짓고, 개발 환경에서 로그를 남기는 미들웨어를 추가하면 훨씬 수월해진다.

```javascript
function withDebugLog(emitter) {
  const originalEmit = emitter.emit.bind(emitter);

  emitter.emit = (event, data) => {
    console.groupCollapsed(`[Event] ${String(event)}`);
    console.log('payload:', data);
    console.trace('emitted from');
    console.groupEnd();
    originalEmit(event, data);
  };

  return emitter;
}

// 개발 환경에서만 적용
const emitter =
  process.env.NODE_ENV === 'development'
    ? withDebugLog(new TypedEventEmitter())
    : new TypedEventEmitter();
```

### 고빈도 이벤트

스크롤, 리사이즈, 마우스 이동 같은 이벤트를 throttle이나 debounce 없이 옵저버에게 전달하면 성능이 급격히 떨어진다. 팁 하나를 공유하면, throttle을 발행 시점이 아니라 구독 시점에서 적용하면 각 소비자가 자기 상황에 맞는 빈도를 선택할 수 있다. 차트는 100ms마다, 좌표 표시는 500ms마다 업데이트하는 식으로.

---

## 왜 상속이 아니라 합성으로 구현할까

마지막으로 구현 방식에 대한 이야기를 하나 더 하고 싶다.

헤드 퍼스트 디자인 패턴의 옵저버 챕터 후반부에는 흥미로운 경고가 나온다. 자바의 `java.util.Observable`이 클래스로 설계되어 있어서, 옵저버 패턴을 쓰려면 이 클래스를 상속해야 했다. 이게 왜 문제였을까?

자바스크립트로 같은 상황을 재현해보자.

```javascript
// 상속 기반: Observable을 상속해야 옵저버 기능을 쓸 수 있다
class Observable {
  constructor() {
    this.observers = new Set();
  }

  subscribe(observer) {
    this.observers.add(observer);
    return () => this.observers.delete(observer);
  }

  notify(data) {
    this.observers.forEach((cb) => cb(data));
  }
}

class Cart extends Observable {
  constructor() {
    super();
    this.items = [];
  }

  addItem(item) {
    this.items.push(item);
    this.notify({ items: this.items });
  }
}
```

언뜻 깔끔해 보이지만 세 가지 문제가 숨어 있다.

첫째, 자바스크립트도 클래스 상속은 하나만 된다. Cart가 이미 `BaseModel`이나 `EventTarget`을 상속하고 있다면 Observable을 상속할 수 없다. 옵저버 기능 하나 때문에 상속 구조 전체를 재설계해야 한다.

둘째, 상속은 부모 클래스의 내부 구현에 강하게 묶인다. Observable의 `notify` 동작 방식이 바뀌면 Cart도 영향을 받고, 부모의 `constructor`에서 뭔가 달라지면 `super()` 호출부터 점검해야 한다.

셋째, "Cart는 Observable이다"가 맞는 말인가? 상속은 is-a 관계다. "장바구니는 관찰 가능한 것이다"? 어색하다. 장바구니는 장바구니이고, 관찰 가능한 기능을 가진 것이다. 이건 has-a, 즉 합성의 영역이다.

합성 기반으로 바꾸면 이 문제들이 전부 사라진다.

```javascript
// 옵저버 기능을 독립 모듈로 만든다
function createObservable() {
  const listeners = new Map();

  return {
    subscribe(event, callback) {
      if (!listeners.has(event)) listeners.set(event, new Set());
      listeners.get(event).add(callback);
      return () => listeners.get(event)?.delete(callback);
    },

    notify(event, data) {
      listeners.get(event)?.forEach((cb) => cb(data));
    },
  };
}

// Cart는 아무것도 상속하지 않는다
class Cart {
  constructor() {
    this.items = [];
    this.events = createObservable(); // 합성: 옵저버 기능을 "가지고 있다"
  }

  addItem(item) {
    this.items.push(item);
    this.events.notify('item:added', { count: this.items.length });
  }

  subscribe(event, callback) {
    return this.events.subscribe(event, callback);
  }
}
```

Cart는 다른 클래스를 자유롭게 상속할 수 있고, 옵저버 기능은 내부에 합성해서 쓴다. 나중에 옵저버 기능이 필요 없어지면 `events` 프로퍼티만 제거하면 된다. 상속 트리를 건드릴 필요가 없다.

이 교훈은 옵저버 패턴에만 해당되지 않는다. "상속보다 합성을 우선하라"는 GoF 디자인 패턴의 핵심 원칙이고, 프론트엔드에서 커스텀 훅이나 유틸 함수 같은 합성 기반 패턴이 지배적인 이유가 여기에 있다. React가 클래스 컴포넌트에서 함수 컴포넌트 + 훅으로 넘어간 것도 결국 같은 흐름이다.

---

## 마무리

옵저버 패턴은 "상태가 바뀌면 알려준다"는 단순한 아이디어다. 하지만 이 패턴이 프론트엔드에서 작동하는 방식을 정확히 이해하면, `addEventListener`부터 React Query의 캐시 무효화까지 하나의 멘탈 모델로 연결된다.

도입 여부를 판단할 때 자신에게 던질 질문은 하나다.

> **"발행자가 소비자를 직접 알아야 하는가?"**

답이 "아니오"라면, 옵저버 패턴이 자연스러운 선택이다.
