# 옵저버 패턴

## 들어가며

`addEventListener`를 쓸 때, Redux의 `subscribe`를 호출할 때, React Query가 캐시를 갱신할 때 
— 우리는 이미 옵저버 패턴 위에서 코드를 쓰고 있다.

그런데 이 패턴을 정확히 이해하지 못하면 이런 상황이 생긴다.

> 분명 상태를 바꿨는데 UI가 안 바뀐다.
> 컴포넌트를 하나 추가했을 뿐인데 기존 코드를 세 군데나 고쳐야 한다.
> 언마운트했는데 콜백이 계속 호출된다.

이 글에서는 옵저버 패턴이 뭔지, 왜 필요한지, 실무에서 어떻게 쓰이는지를 코드와 함께 정리해보았다.

---

## 옵저버 패턴이 뭔데?

한 줄로 요약하면 이렇다.

> **"내 상태가 바뀌면, 나를 지켜보고 있는 애들한테 알려줄게."**

등장인물은 딱 둘이다.

**Subject (발행자)**
상태를 가지고 있는 쪽이다. 상태가 바뀌면 "바뀌었다!"고 외친다.

**Observer (구독자)**
Subject한테 "나한테도 알려줘"라고 등록해둔 쪽이다. 알림이 오면 각자 할 일을 한다.

유튜브 구독 모델을 떠올리면 쉽다. 채널(Subject)이 영상을 올리면, 구독자(Observer)들에게 알림이 간다. 채널은 구독자가 누구인지 일일이 신경 쓰지 않는다. 그냥 "새 영상 올렸어"라고 알리면 끝이다.

이걸 코드로 옮기면 이렇게 생겼다.

```javascript
class Subject {
  constructor() {
    this.observers = new Set();
  }

  // 구독: "나한테도 알려줘"
  subscribe(observer) {
    this.observers.add(observer);
    // 구독 취소 함수를 반환한다
    return () => this.observers.delete(observer);
  }

  // 알림: "상태 바뀌었어!"
  notify(data) {
    this.observers.forEach((observer) => observer(data));
  }
}
```

20줄도 안 되는 코드지만, 이 구조 하나로 해결할 수 있는 문제가 꽤 많다.

---

## 왜 필요한데? — Before / After로 보자

### 상황: 쇼핑몰 장바구니

장바구니에 상품을 담으면 세 군데가 동시에 반응해야 한다.

- 헤더의 장바구니 뱃지 숫자
- 사이드바의 총 금액
- 추천 섹션의 필터

### ❌ Before — 옵저버 패턴 없이

```javascript
class Cart {
  constructor() {
    this.items = [];

    // Cart가 UI 컴포넌트를 직접 알고 있어야 한다
    this.headerBadge = null;
    this.sidebar = null;
    this.recommendationEngine = null;
  }

  addItem(item) {
    this.items.push(item);

    // UI가 하나 추가될 때마다 여기를 수정해야 한다
    if (this.headerBadge) {
      this.headerBadge.updateCount(this.items.length);
    }
    if (this.sidebar) {
      this.sidebar.updateTotal(this.calculateTotal());
    }
    if (this.recommendationEngine) {
      this.recommendationEngine.refilter(this.items);
    }
    // 위시리스트 비교 기능 추가하면? 여기에 또 if문 추가...
    // 재고 알림 기능 추가하면? 여기에 또 if문 추가...
  }

  calculateTotal() {
    return this.items.reduce((sum, item) => sum + item.price, 0);
  }
}
```

이 코드의 문제를 정리하면 이렇다.

**Cart가 모든 UI를 직접 알아야 한다.**
장바구니라는 도메인 로직이 헤더, 사이드바, 추천 엔진이라는 UI 레이어에 완전히 묶여 있다. 새 기능이 추가될 때마다 Cart 클래스를 열어서 수정해야 한다.

**초기화 순서에 의존한다.**
`sidebar`가 아직 `null`이면? `if` 분기가 필요하다. 컴포넌트가 늦게 마운트되면? 그 사이에 발생한 변경은 놓친다.

**테스트하기 어렵다.**
Cart를 테스트하려면 HeaderBadge, Sidebar, RecommendationEngine의 mock을 전부 만들어야 한다.

### ✅ After — 옵저버 패턴 적용

```javascript
class Cart {
  constructor() {
    this.items = [];
    this.listeners = new Map();
  }

  subscribe(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    this.listeners.get(event).add(callback);

    // 구독 해제 함수를 반환 — 나중에 정리할 때 쓴다
    return () => this.listeners.get(event)?.delete(callback);
  }

  notify(event, data) {
    this.listeners.get(event)?.forEach((cb) => cb(data));
  }

  addItem(item) {
    this.items.push(item);

    // Cart는 누가 듣고 있는지 전혀 모른다
    // 그냥 "아이템 추가됐어"라고 알릴 뿐이다
    this.notify('item:added', {
      items: [...this.items],
      total: this.calculateTotal(),
    });
  }

  calculateTotal() {
    return this.items.reduce((sum, item) => sum + item.price, 0);
  }
}
```

이제 각 UI는 자기가 필요할 때 알아서 구독한다.

```javascript
const cart = new Cart();

// 헤더 뱃지: 개수만 필요하다
const unsubBadge = cart.subscribe('item:added', ({ items }) => {
  headerBadge.updateCount(items.length);
});

// 사이드바: 총액만 필요하다
const unsubSidebar = cart.subscribe('item:added', ({ total }) => {
  sidebar.updateTotal(total);
});

// 추천 엔진: 아이템 목록이 필요하다
const unsubReco = cart.subscribe('item:added', ({ items }) => {
  recommendationEngine.refilter(items);
});

// 나중에 위시리스트 비교 기능이 추가되면?
// Cart는 건드릴 필요 없이, 여기에 구독 한 줄만 추가하면 된다
const unsubWishlist = cart.subscribe('item:added', ({ items }) => {
  wishlist.compare(items);
});

// 컴포넌트가 사라질 때 구독 해제
unsubBadge();
```

**뭐가 달라졌을까?**

Cart 코드는 UI가 몇 개든 상관없이 그대로다. 새로운 소비자가 생겨도 Cart는 한 줄도 안 바뀐다. 각 구독자는 같은 이벤트에서 자기한테 필요한 데이터만 골라 쓴다. 그리고 `subscribe`가 해제 함수를 반환하니까, 메모리 누수 걱정 없이 생명주기를 관리할 수 있다.

---

## 핵심 원칙: 느슨한 결합 (Loose Coupling)

헤드 퍼스트 디자인 패턴에서는 옵저버 패턴을 설명하면서 하나의 디자인 원칙을 강조한다.

> **"상호작용하는 객체 사이에는 가능하면 느슨한 결합을 사용해야 한다."**

느슨한 결합이란, 두 객체가 서로 상호작용하지만 서로에 대해 잘 모르는 관계를 말한다. 위의 Before/After 코드를 이 원칙으로 다시 보면, 단순히 "코드가 깔끔해졌다"를 넘어서 구조적으로 뭐가 좋아졌는지 명확해진다.

**Subject는 Observer의 구체적인 구현을 모른다.**
Cart는 "콜백 함수가 등록되어 있다"는 사실만 안다. 그게 헤더 뱃지를 업데이트하는 함수인지, 로그를 찍는 함수인지, API를 호출하는 함수인지 전혀 모른다. 알 필요도 없다.

**Observer는 언제든 추가하고 제거할 수 있다.**
런타임에 새로운 구독자가 들어와도, 기존 구독자가 빠져도, Subject 코드는 한 줄도 바뀌지 않는다. 이건 단순한 편의가 아니라, 시스템이 확장될 때 기존 코드를 건드리지 않아도 된다는 뜻이다(OCP, 개방-폐쇄 원칙).

**Subject와 Observer는 독립적으로 재사용할 수 있다.**
Cart 클래스를 다른 프로젝트에 가져가도 그대로 동작한다. 구독자가 없으면 `notify`가 아무 일도 안 할 뿐이지, 에러가 나거나 특정 UI에 의존하지 않는다.

**한쪽이 바뀌어도 다른 쪽에 영향을 주지 않는다.**
사이드바의 UI를 완전히 뜯어고쳐도 Cart는 모른다. Cart의 내부 로직이 바뀌어도, `notify`로 보내는 데이터 구조만 유지하면 모든 구독자는 그대로 동작한다.

코드로 보면 이런 의미다.

```javascript
// Cart는 이 함수들이 뭘 하는지 전혀 모른다
// 그저 "콜백이 등록되어 있으니 호출한다"일 뿐
cart.subscribe('item:added', updateBadge);    // UI 업데이트? 몰라
cart.subscribe('item:added', sendAnalytics);  // 분석 이벤트? 몰라
cart.subscribe('item:added', syncToServer);   // 서버 동기화? 몰라

// 이 세 줄 중 어떤 것을 빼도, 추가해도, Cart 클래스는 변하지 않는다
```

느슨한 결합이 주는 가장 실질적인 이점은 **변경의 파급 범위가 좁아진다**는 것이다. 프론트엔드에서 요구사항 변경은 일상이다. "여기에 알림도 띄워주세요", "이 데이터를 분석 툴에도 보내주세요" 같은 요청이 올 때, 느슨하게 결합된 시스템에서는 구독 한 줄을 추가하면 끝이다. 강하게 결합된 시스템에서는 기존 코드를 열어서 수정해야 한다.

---

## Push vs Pull: 데이터를 밀어줄까, 당겨갈까

옵저버 패턴을 구현할 때 중요한 설계 결정이 하나 있다. 상태가 바뀌었을 때, Subject가 데이터를 **밀어줄지(Push)**, Observer가 필요한 걸 **가져갈지(Pull)** 를 결정해야 한다.

### Push 방식: "여기 데이터야, 다 가져가"

Subject가 변경된 데이터를 알림과 함께 보내준다. 앞에서 본 코드가 전부 이 방식이다.

```javascript
// Subject가 필요할 것 같은 데이터를 한꺼번에 밀어준다
notify('item:added', {
  items: [...this.items],
  total: this.calculateTotal(),
  count: this.items.length,
  lastAdded: item,
});
```

편리하지만 문제가 있다. Subject가 "구독자들이 뭘 필요로 할지"를 미리 예측해서 데이터를 구성해야 한다. 구독자가 늘어날수록 보내야 할 데이터도 점점 비대해진다. 뱃지 컴포넌트는 `count`만 필요한데, 매번 전체 `items` 배열 복사본을 받는 건 낭비다.

### Pull 방식: "바뀐 건 알겠고, 내가 필요한 것만 가져갈게"

Subject는 "바뀌었다"는 사실만 알리고, Observer가 Subject에게 직접 물어서 필요한 데이터를 가져간다.

```javascript
class Cart {
  constructor() {
    this.items = [];
    this.listeners = new Set();
  }

  subscribe(callback) {
    this.listeners.add(callback);
    return () => this.listeners.delete(callback);
  }

  // "바뀌었다"는 사실만 알린다. 데이터는 보내지 않는다.
  notify() {
    this.listeners.forEach((cb) => cb());
  }

  addItem(item) {
    this.items.push(item);
    this.notify(); // 데이터 없이 알림만
  }

  // Observer가 필요할 때 직접 꺼내가는 getter들
  getItems() {
    return [...this.items];
  }

  getTotal() {
    return this.items.reduce((sum, item) => sum + item.price, 0);
  }

  getCount() {
    return this.items.length;
  }
}

const cart = new Cart();

// 뱃지: count만 필요하니까 count만 가져간다
cart.subscribe(() => {
  headerBadge.updateCount(cart.getCount());
});

// 사이드바: total만 가져간다
cart.subscribe(() => {
  sidebar.updateTotal(cart.getTotal());
});
```

Pull 방식에서는 Subject가 구독자의 요구사항을 몰라도 된다. 각 Observer가 자기한테 필요한 것만 가져가니까 데이터 낭비도 없다.

### 그래서 뭘 써야 하나?

실무에서는 **둘을 적절히 섞는 게 가장 흔하다.**

```javascript
// 하이브리드: 자주 쓰는 핵심 데이터는 Push, 나머지는 Pull
addItem(item) {
  this.items.push(item);

  // 대부분의 구독자가 필요로 하는 최소한의 데이터만 Push
  this.notify('item:added', { count: this.items.length });

  // 전체 아이템 목록이 필요한 구독자는 직접 Pull
  // cart.getItems()로 가져감
}
```

Redux가 딱 이 하이브리드 방식이다. `dispatch`하면 "상태 바뀌었어"라고 알리고(Push), 각 컴포넌트는 `useSelector`로 자기한테 필요한 조각만 꺼내간다(Pull). React Query도 마찬가지다. 캐시가 업데이트되면 알림이 가고, 각 `useQuery` 훅이 자기 쿼리 키에 해당하는 데이터만 가져간다.

---

## 바닐라 JS로 SPA 만들 때의 상태 관리

프레임워크 없이 SPA를 만들어본 적이 있다면, 상태가 바뀔 때 DOM을 직접 업데이트하는 게 얼마나 번거로운지 알 거다. 옵저버 패턴으로 간단한 상태 관리 시스템을 만들면 이 문제가 깔끔하게 풀린다.

### 핵심: 상태가 바뀌면 → 화면이 알아서 다시 그려진다

```javascript
function createStore(initialState) {
  let state = initialState;
  const listeners = new Set();

  return {
    getState() {
      return state;
    },

    setState(updater) {
      // 함수를 받아서 이전 상태 기반으로 새 상태를 만든다
      const nextState =
        typeof updater === 'function' ? updater(state) : updater;
      state = { ...state, ...nextState };

      // 상태가 바뀌면 모든 구독자에게 알린다 — 이게 옵저버 패턴이다
      listeners.forEach((listener) => listener(state));
    },

    subscribe(listener) {
      listeners.add(listener);
      return () => listeners.delete(listener);
    },
  };
}
```

이 30줄짜리 `createStore`가 하는 일은 React의 `useState`와 본질적으로 같다. 상태를 보관하고, 바뀌면, 구독자에게 알린다.

### 실제 SPA에 적용해보자: 할 일 앱

```javascript
// 1. 스토어 생성
const store = createStore({
  todos: [],
  filter: 'all', // 'all' | 'active' | 'completed'
});

// 2. 컴포넌트: 각자 자기 영역만 다시 그린다
function renderTodoList(state) {
  const list = document.getElementById('todo-list');
  const filtered = state.todos.filter((todo) => {
    if (state.filter === 'active') return !todo.done;
    if (state.filter === 'completed') return todo.done;
    return true;
  });

  list.innerHTML = filtered
    .map(
      (todo) => `
      <li data-id="${todo.id}" class="${todo.done ? 'completed' : ''}">
        <label>
          <input type="checkbox" ${todo.done ? 'checked' : ''} />
          ${todo.text}
        </label>
        <button class="delete-btn">삭제</button>
      </li>
    `
    )
    .join('');
}

function renderCount(state) {
  const counter = document.getElementById('todo-count');
  const active = state.todos.filter((t) => !t.done).length;
  counter.textContent = `할 일 ${active}개 남음`;
}

function renderFilter(state) {
  document.querySelectorAll('[data-filter]').forEach((btn) => {
    btn.classList.toggle('active', btn.dataset.filter === state.filter);
  });
}

// 3. 구독 — 상태가 바뀌면 각 렌더 함수가 자동으로 호출된다
store.subscribe(renderTodoList);
store.subscribe(renderCount);
store.subscribe(renderFilter);

// 4. 이벤트 핸들러: 상태만 바꾸면 된다. DOM 업데이트는 신경 쓰지 않는다.
document.getElementById('todo-form').addEventListener('submit', (e) => {
  e.preventDefault();
  const input = e.target.querySelector('input');

  store.setState((prev) => ({
    todos: [
      ...prev.todos,
      { id: Date.now(), text: input.value, done: false },
    ],
  }));

  input.value = '';
});

document.getElementById('todo-list').addEventListener('click', (e) => {
  const li = e.target.closest('li');
  if (!li) return;
  const id = Number(li.dataset.id);

  // 체크박스 토글
  if (e.target.type === 'checkbox') {
    store.setState((prev) => ({
      todos: prev.todos.map((t) =>
        t.id === id ? { ...t, done: !t.done } : t
      ),
    }));
  }

  // 삭제
  if (e.target.classList.contains('delete-btn')) {
    store.setState((prev) => ({
      todos: prev.todos.filter((t) => t.id !== id),
    }));
  }
});

document.querySelector('.filters').addEventListener('click', (e) => {
  if (e.target.dataset.filter) {
    store.setState({ filter: e.target.dataset.filter });
  }
});

// 5. 초기 렌더
store.setState({});
```

여기서 주목할 점은 **이벤트 핸들러가 DOM을 직접 건드리지 않는다**는 것이다.

옵저버 패턴이 없었다면 할 일을 추가하는 코드에서 `list.innerHTML`도 바꾸고, `counter.textContent`도 바꾸고, 필터 상태도 체크해야 한다. 기능이 추가될 때마다 모든 핸들러를 다 열어서 수정해야 한다.

옵저버 패턴 덕분에 흐름이 단방향으로 정리된다.

> **이벤트 → setState → notify → 각 렌더 함수 자동 호출**

이 구조가 익숙하게 느껴진다면 맞다. React, Vue, Svelte 같은 프레임워크들이 내부적으로 하는 일이 정확히 이것이다. 프레임워크가 우리 대신 옵저버 패턴을 구현해주고 있을 뿐이다.

---

## 언제 옵저버 패턴을 도입해야 할까?

모든 상태 공유에 옵저버 패턴이 필요한 건 아니다. 다음 중 2개 이상 해당되면 도입을 고려할 시점이다.

### 1. 상태 변경을 받아야 하는 쪽이 유동적이다

소비자가 고정되어 있으면 그냥 직접 호출하는 게 낫다. 하지만 런타임에 소비자가 추가되거나 제거된다면 — 예를 들어 동적으로 마운트되는 위젯, 플러그인 시스템, 대시보드 타일 — 옵저버 패턴이 자연스러운 해법이다.

### 2. 하나의 이벤트를 여러 관점에서 해석해야 한다

Cart 예시를 다시 보자. "아이템 추가됨"이라는 하나의 이벤트를 뱃지는 "개수"로, 사이드바는 "총액"으로, 추천 엔진은 "카테고리 분포"로 해석한다. 같은 사건인데 관심사가 다 다르다. 이런 경우에 옵저버 패턴이 딱 맞는다.

### 3. 의존 방향을 뒤집어야 한다

Cart → HeaderBadge 방향의 의존은 도메인이 UI를 아는 구조다. 이건 뒤집어야 한다. 옵저버 패턴을 쓰면 UI가 도메인을 구독하는 형태가 되고, 클린 아키텍처의 의존성 규칙과 자연스럽게 맞아 떨어진다.

### 4. Prop drilling이 감당이 안 된다

React에서 3단계 이상의 prop drilling이 발생하거나, 형제 컴포넌트끼리 상태를 공유해야 할 때, Context나 전역 스토어보다 가벼운 이벤트 기반 통신이 더 효율적일 수 있다.

---

## TypeScript로 타입 안전하게 만들기

실무에서 이벤트 이름을 문자열로만 관리하면 금방 기술 부채가 된다. 오타 하나에 버그가 생기고, 어떤 이벤트에 어떤 데이터가 오는지 코드만 봐서는 알 수 없다.

TypeScript의 제네릭으로 이벤트 맵을 정의하면, 구독하는 시점에 타입이 자동으로 추론된다.

```typescript
// 이벤트 이름과 데이터 형태를 한 곳에서 정의한다
type EventMap = {
  'cart:updated': { items: CartItem[]; total: number };
  'auth:changed': { isLoggedIn: boolean; userId: string | null };
  'theme:toggled': { mode: 'light' | 'dark' };
};

class TypedEventEmitter<T extends Record<string, unknown>> {
  private listeners = new Map<keyof T, Set<(data: any) => void>>();

  on<K extends keyof T>(event: K, callback: (data: T[K]) => void): () => void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    this.listeners.get(event)!.add(callback);
    return () => this.listeners.get(event)?.delete(callback);
  }

  emit<K extends keyof T>(event: K, data: T[K]): void {
    this.listeners.get(event)?.forEach((cb) => cb(data));
  }
}
```

사용할 때의 경험이 확 달라진다.

```typescript
const emitter = new TypedEventEmitter<EventMap>();

// ✅ data의 타입이 자동 추론된다
emitter.on('cart:updated', (data) => {
  console.log(data.total); // number
  console.log(data.items); // CartItem[]
});

// ✅ 잘못된 이벤트 이름은 컴파일 에러
emitter.on('cart:updateddd', () => {}); // ❌ 타입 에러!

// ✅ 잘못된 데이터 형태도 컴파일 에러
emitter.emit('auth:changed', { isLoggedIn: 'yes' }); // ❌ boolean이어야 함
```

이벤트 이름 오타, 잘못된 페이로드 구조 같은 실수를 런타임이 아니라 코드를 쓰는 시점에 잡을 수 있다.

---

## 실무 활용 사례

### 사례 1: 전역 토스트 알림 시스템

여러 곳에서 토스트를 띄워야 하는데, Toast UI 컴포넌트는 앱에 하나만 있다. API 에러 인터셉터에서도, 폼 제출 성공 시에도, 웹소켓 이벤트에서도 토스트를 띄워야 한다.

옵저버 패턴 없이는? Toast 컴포넌트의 setState에 접근할 방법을 모든 곳에 만들어줘야 한다. 옵저버 패턴으로는? 이벤트 하나 발행하면 끝이다.

```javascript
// toast-bus.js — 앱 전체에서 공유하는 이벤트 버스
const toastBus = new TypedEventEmitter();

// === 발행하는 쪽 (여러 곳) ===

// API 에러 인터셉터
axios.interceptors.response.use(null, (error) => {
  toastBus.emit('toast:show', {
    type: 'error',
    message: error.response?.data?.message ?? '요청에 실패했습니다.',
  });
  return Promise.reject(error);
});

// 폼 제출 성공
toastBus.emit('toast:show', {
  type: 'success',
  message: '저장되었습니다.',
});

// === 구독하는 쪽 (딱 한 곳) ===

function ToastContainer() {
  const [toasts, setToasts] = useState([]);

  useEffect(() => {
    const unsub = toastBus.on('toast:show', (toast) => {
      const id = crypto.randomUUID();
      setToasts((prev) => [...prev, { ...toast, id }]);
      setTimeout(() => {
        setToasts((prev) => prev.filter((t) => t.id !== id));
      }, 3000);
    });
    return unsub; // 언마운트 시 구독 해제
  }, []);

  return toasts.map((t) => <Toast key={t.id} {...t} />);
}
```

발행자가 누구든, 몇 명이든 상관없다. Toast 컴포넌트는 그냥 `toast:show` 이벤트를 듣고 있을 뿐이다.

### 사례 2: WebSocket 메시지 라우팅

하나의 WebSocket 연결로 채팅, 알림, 실시간 데이터가 전부 들어온다. 이걸 각각의 컴포넌트에 어떻게 분배할까?

```javascript
class WebSocketRouter {
  constructor(url) {
    this.emitter = new TypedEventEmitter();
    this.ws = new WebSocket(url);

    this.ws.onmessage = (event) => {
      const { type, payload } = JSON.parse(event.data);
      // 메시지 타입을 이벤트 이름으로 변환해서 발행한다
      this.emitter.emit(type, payload);
    };
  }

  on(messageType, handler) {
    return this.emitter.on(messageType, handler);
  }
}

const ws = new WebSocketRouter('wss://api.example.com/ws');

// 각 컴포넌트는 자기한테 필요한 메시지만 구독한다
ws.on('chat:message', (msg) => appendMessage(msg));
ws.on('notification', (notif) => showNotification(notif));
ws.on('data:tick', (tick) => updateChart(tick));
```

WebSocket 라우터는 채팅 컴포넌트가 있는지, 차트가 있는지 모른다. 메시지가 오면 타입별로 발행할 뿐이고, 해당 타입을 구독하고 있는 쪽이 알아서 처리한다.

### 사례 3: 멀티 스텝 폼 상태 동기화

Step 3에서 입력한 보험 정보가 Step 1의 요약 미리보기에 실시간으로 반영되어야 한다. prop drilling 없이, 전역 스토어 없이.

```javascript
const formBus = new TypedEventEmitter();

// Step 3: 보험 정보 입력
function InsuranceStep() {
  const handleChange = (field, value) => {
    formBus.emit('form:field-changed', {
      step: 'insurance',
      field,
      value,
    });
  };
  // ...
}

// Step 1의 요약 미리보기 — Step 3의 존재를 모른다
function SummaryPreview() {
  const [preview, setPreview] = useState({});

  useEffect(() => {
    return formBus.on('form:field-changed', ({ step, field, value }) => {
      setPreview((prev) => ({
        ...prev,
        [`${step}.${field}`]: value,
      }));
    });
  }, []);

  return <PreviewCard data={preview} />;
}
```

### 사례 4: IntersectionObserver로 무한 스크롤

브라우저 네이티브 API인 `IntersectionObserver`도 이름 그대로 옵저버 패턴이다. 특정 요소가 화면에 보이는지를 "관찰"하고, 보이면 알려준다.

```javascript
function useIntersectionObserver(callback, options = {}) {
  const targetRef = useRef(null);

  useEffect(() => {
    const observer = new IntersectionObserver(([entry]) => {
      if (entry.isIntersecting) callback();
    }, options);

    const target = targetRef.current;
    if (target) observer.observe(target);

    // cleanup: 관찰 해제 — 빠뜨리면 메모리 누수
    return () => {
      if (target) observer.unobserve(target);
    };
  }, [callback, options.threshold, options.root]);

  return targetRef;
}

// 사용
function ProductList() {
  const { data, fetchNextPage } = useInfiniteQuery(/* ... */);
  const sentinelRef = useIntersectionObserver(fetchNextPage);

  return (
    <>
      {data.pages.flat().map((product) => (
        <ProductCard key={product.id} {...product} />
      ))}
      {/* 이 빈 div가 화면에 보이면 → 다음 페이지 로드 */}
      <div ref={sentinelRef} />
    </>
  );
}
```

---

## 사실 이미 쓰고 있는 옵저버 패턴들

프론트엔드 생태계 곳곳에 옵저버 패턴이 녹아 있다. 이걸 인식하면 각 도구의 설계 의도가 더 선명하게 보인다.

| 도구 / API | Subject (발행자) | Observer (구독자) | 언제 알림이 가나? |
|---|---|---|---|
| `addEventListener` | DOM 요소 | 이벤트 핸들러 | 클릭, 입력 등 사용자 인터랙션 |
| React `useState` | 컴포넌트 상태 | 렌더 함수 | `setState` 호출 |
| Redux `store.subscribe` | Store | Listener 함수 | `dispatch` |
| `MutationObserver` | DOM 노드 | 콜백 함수 | DOM 구조 변경 |
| `IntersectionObserver` | 타겟 요소 | 콜백 함수 | 뷰포트 교차 |
| RxJS `Observable` | 데이터 스트림 | Subscriber | 새 값 발행 |
| React Query | 쿼리 캐시 | 컴포넌트 | 캐시 무효화/갱신 |

---

## 옵저버 패턴의 함정들

패턴이 유용한 만큼, 잘못 쓰면 생기는 문제도 명확하다.

### 함정 1: 메모리 누수

가장 흔한 실수다. 구독해놓고 해제를 안 하면, 컴포넌트가 화면에서 사라져도 콜백은 계속 호출된다.

React에서는 `useEffect`의 cleanup에서 반드시 unsubscribe를 호출해야 한다. 앞서 본 것처럼 `subscribe`가 해제 함수를 반환하는 패턴을 쓰면 이걸 구조적으로 강제할 수 있다.

```javascript
useEffect(() => {
  const unsub = emitter.on('some:event', handler);
  return unsub; // ← 이걸 빠뜨리면 메모리 누수
}, []);
```

### 함정 2: 실행 순서에 의존하는 코드

옵저버들이 호출되는 순서는 보장되지 않는다. "A 옵저버가 먼저 실행되고 나서 B가 실행되어야 해"라는 로직이 있다면, 그건 옵저버 패턴을 잘못 쓰고 있다는 신호다. 순서가 중요하면 파이프라인 패턴이나 미들웨어 체인을 고려해야 한다.

### 함정 3: 디버깅이 어렵다

이벤트 기반 시스템은 콜스택만 보고 흐름을 추적하기 어렵다. 이벤트 이름을 `domain:action` 형태로 일관되게 짓고, 개발 환경에서 로그를 남기는 미들웨어를 추가하면 훨씬 수월해진다.

```javascript
function withDebugLog(emitter) {
  const originalEmit = emitter.emit.bind(emitter);

  emitter.emit = (event, data) => {
    console.groupCollapsed(`[Event] ${String(event)}`);
    console.log('payload:', data);
    console.trace('emitted from');
    console.groupEnd();
    originalEmit(event, data);
  };

  return emitter;
}

// 개발 환경에서만 적용
const emitter =
  process.env.NODE_ENV === 'development'
    ? withDebugLog(new TypedEventEmitter())
    : new TypedEventEmitter();
```

### 함정 4: 고빈도 이벤트 폭탄

스크롤, 리사이즈, 마우스 이동 같은 이벤트를 throttle이나 debounce 없이 옵저버에게 전달하면 성능이 급격히 떨어진다.

팁 하나: throttle을 발행 시점이 아니라 **구독 시점에서** 적용하면, 각 소비자가 자기 상황에 맞는 빈도를 선택할 수 있다. 차트는 100ms마다 업데이트하고, 좌표 표시는 500ms마다 업데이트하는 식으로.

---

## 왜 상속이 아니라 합성으로 구현할까

헤드 퍼스트 디자인 패턴의 옵저버 챕터 후반부에는 흥미로운 경고가 나온다. 자바의 `java.util.Observable`이 **클래스**로 설계되어 있어서 생긴 문제들을 지적하는 부분이다.

자바에서는 옵저버 패턴을 쓰려면 `Observable` 클래스를 **상속**해야 했다. 이게 왜 문제였을까?

```javascript
// ❌ 상속 기반 접근 — 자바의 Observable이 가졌던 문제를 JS로 재현
class Observable {
  constructor() {
    this.observers = new Set();
  }

  subscribe(observer) {
    this.observers.add(observer);
    return () => this.observers.delete(observer);
  }

  notify(data) {
    this.observers.forEach((cb) => cb(data));
  }
}

// Cart가 Observable을 상속해야 한다
class Cart extends Observable {
  constructor() {
    super();
    this.items = [];
  }

  addItem(item) {
    this.items.push(item);
    this.notify({ items: this.items });
  }
}
```

언뜻 보면 괜찮아 보이지만, 세 가지 문제가 있다.

**첫째, 단일 상속의 제약.**
자바스크립트도 클래스 상속은 하나만 된다. Cart가 이미 `BaseModel`이나 `EventTarget` 같은 걸 상속하고 있다면? Observable을 상속할 수 없다. 옵저버 기능을 쓰겠다는 이유로 상속 구조 전체를 재설계해야 한다.

**둘째, 구현 내부에 대한 의존.**
상속은 부모 클래스의 내부 구현에 강하게 묶인다. Observable의 `notify` 동작 방식이 바뀌면 Cart도 영향을 받는다. 부모의 `constructor`에서 뭔가 바뀌면 `super()` 호출부터 점검해야 한다.

**셋째, "Cart는 Observable이다"가 맞는 말인가?**
상속은 is-a 관계다. "장바구니는 관찰 가능한 것이다"? 어색하다. 장바구니는 장바구니이고, 관찰 가능한 **기능을 가진** 것이다. 이건 has-a, 즉 합성(Composition)의 영역이다.

합성 기반으로 바꾸면 이렇게 된다.

```javascript
// ✅ 합성 기반 접근 — 옵저버 기능을 "가지고 있는" 구조
function createObservable() {
  const listeners = new Map();

  return {
    subscribe(event, callback) {
      if (!listeners.has(event)) listeners.set(event, new Set());
      listeners.get(event).add(callback);
      return () => listeners.get(event)?.delete(callback);
    },

    notify(event, data) {
      listeners.get(event)?.forEach((cb) => cb(data));
    },
  };
}

// Cart는 아무것도 상속하지 않는다
// 옵저버 기능이 필요하면 그냥 가져다 쓴다
class Cart {
  constructor() {
    this.items = [];
    this.events = createObservable(); // 합성: "가지고 있다"
  }

  addItem(item) {
    this.items.push(item);
    this.events.notify('item:added', {
      count: this.items.length,
    });
  }

  // 외부에 subscribe만 노출한다
  subscribe(event, callback) {
    return this.events.subscribe(event, callback);
  }
}
```

Cart는 다른 클래스를 자유롭게 상속할 수 있고, 옵저버 기능은 내부적으로 합성해서 쓴다. 나중에 옵저버 기능이 필요 없어지면 `events` 프로퍼티만 제거하면 된다. 상속 구조를 바꿀 필요가 없다.

이 교훈은 옵저버 패턴에만 해당하는 게 아니다. **"상속보다 합성을 우선하라"** 는 GoF 디자인 패턴의 핵심 원칙 중 하나이고, 프론트엔드에서도 커스텀 훅, 유틸 함수, 믹스인 등 합성 기반 패턴이 지배적인 이유가 여기에 있다. React가 클래스 컴포넌트에서 함수 컴포넌트 + 훅으로 넘어간 것도 결국 같은 맥락이다.

---

## 마무리

옵저버 패턴은 "상태가 바뀌면 알려준다"는 단순한 아이디어다. 하지만 프론트엔드에서 이 패턴이 작동하는 방식을 정확히 이해하면, `addEventListener`부터 React Query의 캐시 무효화까지 하나의 멘탈 모델로 연결된다.

도입 여부를 판단할 때 자신에게 던질 질문은 하나다.

> **"발행자가 소비자를 직접 알아야 하는가?"**

답이 "아니오"라면, 옵저버 패턴이 자연스러운 선택이다.
